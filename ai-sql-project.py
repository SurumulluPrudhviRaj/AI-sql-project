# -*- coding: utf-8 -*-
# This line sets the encoding of the Python file to UTF-8.
# It ensures the program can handle special characters (e.g., non-English text) correctly.
 
# =========================================
# 1. IMPORTING REQUIRED PYTHON LIBRARIES
# =========================================
 
# 're' = Regular Expressions. We'll use this to clean SQL text generated by the AI.
import re
 
# 'mysql.connector' is a library that allows Python to connect to a MySQL database.
import mysql.connector
 
# 'Error' helps us catch and handle MySQL-specific errors if something goes wrong.
from mysql.connector import Error
 
# 'OpenAI' is the official library to interact with GPT models like GPT-4.
from openai import OpenAI
 
# 'streamlit' is a Python framework that lets us build interactive web apps easily.
import streamlit as st
 
# 'pandas' is used to work with tabular data (rows and columns) and display results nicely.
import pandas as pd
 
# 'version' from the 'packaging' module helps us compare version numbers easily.
from packaging import version
 
# =========================================
# 2. CONFIGURATION SECTION
# =========================================
# In this section, we set up:
#   - OpenAI API Key (to talk to GPT)
#   - MySQL connection details (host, username, password, database)
# Replace the placeholders with your actual details.
 
OPENAI_API_KEY = "*******"       # Insert your OpenAI API key here (e.g., "sk-xxxxx")
MYSQL_HOST = "localhost"  # "localhost" means the MySQL server is running on your own machine
MYSQL_USER = "root"       # Default MySQL username is often "root"
MYSQL_PASS = "**"     # Replace ***** with your actual MySQL password
DEFAULT_DB = "**"       # Replace **** with the database name you want to connect to by default
 
# =========================================
# 3. STREAMLIT VERSION CHECK
# =========================================
# Streamlit adds new UI features (e.g., dialog boxes, modals) in specific versions.
# We check the installed version of Streamlit to know what features are supported.
 
STREAMLIT_HAS_DIALOG = version.parse(st.__version__) >= version.parse("1.38.0")
# True if the current Streamlit version is 1.38.0 or newer
 
STREAMLIT_HAS_MODAL = version.parse(st.__version__) >= version.parse("1.33.0")
# True if the current Streamlit version is 1.33.0 or newer
 
# =========================================
# 4. STREAMLIT SESSION STATE INITIALIZATION
# =========================================
# Streamlit runs the entire script from top to bottom each time the user interacts.
# So, to remember values (e.g., database connection, last query), we use st.session_state.
# Think of it as a "memory" that persists between user actions.
 
# Check if 'current_db' is stored in session_state. If not, set it to DEFAULT_DB.
if "current_db" not in st.session_state:
    st.session_state.current_db = DEFAULT_DB
 
# Check if a MySQL connection object exists in session_state. If not, set it to None.
if "conn" not in st.session_state:
    st.session_state.conn = None
 
# Check if a MySQL cursor exists. If not, set it to None.
# A "cursor" is an object that lets us run SQL commands against the database.
if "cursor" not in st.session_state:
    st.session_state.cursor = None
 
# This will later store the explanation generated by GPT for the last executed query.
if "last_explanation" not in st.session_state:
    st.session_state.last_explanation = None
 
# =========================================
# 5. FUNCTION: connect_to_db()
# =========================================
# This function connects to the MySQL database using the credentials defined above.
# It saves the connection and cursor inside session_state for use across the app.
 
def connect_to_db(db_name):
    """
    Connect to a MySQL database and store the connection in Streamlit's session_state.
    Arguments:
        db_name (str): The name of the database to connect to.
    Returns:
        True if connection is successful, False otherwise.
    """
    try:
        # If there is already an existing connection, close it before opening a new one.
        if st.session_state.conn:
            st.session_state.conn.close()
 
        # Create a new MySQL connection
        conn = mysql.connector.connect(
            host=MYSQL_HOST,      # Host where MySQL server is running
            user=MYSQL_USER,      # Username to log in
            password=MYSQL_PASS,  # Password for that user
            database=db_name      # Database to use by default after connecting
        )
 
        # Store the connection object
        st.session_state.conn = conn
 
        # Create and store a cursor object, which allows us to execute SQL queries
        # buffered=True means we can run multiple queries without problems
        st.session_state.cursor = conn.cursor(buffered=True)
 
        # Store the current database name in session_state for display and switching
        st.session_state.current_db = db_name
 
        # Return True to indicate connection was successful
        return True
 
    except Error as e:
        # If something goes wrong (e.g., wrong credentials or DB doesn't exist),
        # show the error message on the web UI.
        st.error(f" Failed to connect to `{db_name}`: {e}")
        return False
 
# Establish the initial connection to the default database when the app loads.
connect_to_db(st.session_state.current_db)
 
# =========================================
# 6. INITIALIZE OPENAI CLIENT
# =========================================
# This sets up the connection to OpenAI so we can send instructions to GPT.
# We'll use this client to:
#   - Convert natural language → SQL queries
#   - Generate explanations for SQL queries
 
client = OpenAI(api_key=OPENAI_API_KEY)
# =========================================
# 7. HELPER FUNCTION: clean_sql()
# =========================================
# Purpose:
#   - GPT sometimes returns SQL queries wrapped inside code blocks like ```sql ... ```
#   - This function removes those wrappers and any extra characters
#   - It also ensures that the final SQL ends with a semicolon (;) for proper execution
 
def clean_sql(text: str) -> str:
    """
    Cleans up the SQL text generated by the AI by removing Markdown code block wrappers and stray backticks.
    Also ensures the SQL ends with a semicolon.
    """
    # Use regular expressions to find and remove ```sql ... ``` wrappers if they exist
    cleaned = re.sub(
        r"```(?:sql)?\s*([\s\S]*?)\s*```",  # Pattern: ```sql <anything> ```
        r"\1",                             # Replace with just the content inside
        text,
        flags=re.IGNORECASE
    ).strip()
 
    # Remove any stray backticks ` around the SQL
    cleaned = cleaned.strip("`").strip()
 
    # Ensure SQL ends with a semicolon
    if not cleaned.endswith(";"):
        cleaned += ";"
 
    return cleaned
 
 
# =========================================
# 8. HELPER FUNCTION: get_existing_tables()
# =========================================
# Purpose:
#   - To list all the tables that exist in the currently connected database.
#   - Useful because GPT needs to know what tables are available when generating SQL.
#   - We'll show this info to the user in the UI as well.
 
def get_existing_tables():
    """
    Returns a list of table names from the currently selected database.
    """
    # Get the cursor object from session_state
    cur = st.session_state.cursor
 
    # Execute SHOW TABLES to retrieve all tables in the current database
    cur.execute("SHOW TABLES;")
 
    # Fetch all rows returned by the query
    # Each row contains a table name, so we extract [0] from each
    return [r[0] for r in cur.fetchall()]
 
 
# =========================================
# 9. HELPER FUNCTION: get_table_schema()
# =========================================
# Purpose:
#   - Given a table name, this function retrieves its schema (columns, types, keys, etc.)
#   - GPT uses this information to generate accurate SQL queries
#   - We also display this in the "Table Schemas" tab in the UI
 
def get_table_schema(table_name):
    """
    Returns the schema (columns and attributes) of a given table.
    """
    try:
        # Use the cursor to describe the table
        cur = st.session_state.cursor
        cur.execute(f"DESCRIBE `{table_name}`;")
 
        # Each row returned contains: Field, Type, Null, Key, Default, Extra
        return cur.fetchall()
 
    except:
        # If anything goes wrong (e.g., table doesn't exist), return an empty list
        return []
 
 
# =========================================
# 10. HELPER FUNCTION: text_to_sql()
# =========================================
# Purpose:
#   - Converts natural language instructions from the user into a valid MySQL query.
#   - Example:
#       Input:  "Show me all customers who purchased in 2023"
#       Output: "SELECT * FROM customers WHERE purchase_year = 2023;"
#   - Uses GPT model (gpt-4.1-mini) for this.
#   - Gives GPT a list of available tables and their schemas so it generates valid SQL.
 
def text_to_sql(user_text: str) -> str:
    """
    Converts a natural language instruction into a valid MySQL SQL query using GPT.
    """
    # 1. Get all existing tables in the current database
    tables = get_existing_tables()
 
    # 2. Build a dictionary of {table_name: [list of column names]} for all tables
    schema_info = {t: [c[0] for c in get_table_schema(t)] for t in tables}
 
    # 3. Create a structured prompt for GPT to follow strictly
    prompt = f"""
You are a MySQL 8.0 SQL generator.
Existing tables: {tables}
Schemas: {schema_info}
Rules:
- Only use real columns
- Return ONLY valid MySQL SQL
- No explanations
User: "{user_text}"
    """
 
    # 4. Send the prompt to OpenAI GPT to generate the SQL
    resp = client.responses.create(model="gpt-4.1-mini", input=prompt)
 
    # 5. Clean the SQL returned by GPT using the clean_sql() function above
    return clean_sql(resp.output_text)
 
 
# =========================================
# 11. HELPER FUNCTION: run_query()
# =========================================
# Purpose:
#   - Executes one or multiple SQL queries entered/generated by the app.
#   - Handles different query types:
#       * SELECT/SHOW/DESCRIBE → fetch and display data
#       * USE db_name          → switch database
#       * INSERT/UPDATE/DELETE → modify data and commit
#   - Captures errors and returns structured results for UI display.
 
def run_query(sql_query: str):
    """
    Executes the given SQL query or multiple queries separated by semicolons.
    Returns a list of tuples describing the results.
    Each result item has the form: (rtype, headers, rows, stmt)
        - rtype: "data" | "info" | "error"
        - headers: column names (for data)
        - rows: actual data rows (or error messages)
        - stmt: the original SQL statement executed
    """
    results = []  # Will store results of each statement separately
 
    # Retrieve cursor and connection from session_state
    cur = st.session_state.cursor
    conn = st.session_state.conn
 
    # Some inputs may have multiple queries separated by ";"
    # Example: "USE mydb; SELECT * FROM table;"
    statements = [s.strip() for s in sql_query.split(";") if s.strip()]
 
    # Loop through each SQL statement and execute one by one
    for stmt in statements:
        try:
            lower_stmt = stmt.lower()  # lowercase to check what type of query it is
 
            # ---------- SELECT / SHOW / DESCRIBE ----------
            # These are data-retrieval queries
            if lower_stmt.startswith(("select", "show", "describe", "desc")):
                cur.execute(stmt)  # Run the SQL
                rows = cur.fetchall()  # Fetch all returned rows
                headers = [col[0] for col in cur.description] if cur.description else []  # Column names
                results.append(("data", headers, rows, stmt))  # Store result with type 'data'
 
            # ---------- USE ----------
            # This query switches the current database
            elif lower_stmt.startswith("use "):
                cur.execute(stmt)  # Execute USE <db_name>
                cur.execute("SELECT DATABASE();")  # Verify which DB we're in now
                db_name = cur.fetchall()[0][0]
                st.session_state.current_db = db_name
                results.append(("info", ["Message"], [(f"Switched to {db_name}",)], stmt))
 
            # ---------- INSERT / UPDATE / DELETE / OTHERS ----------
            # These modify data and need to be committed to save changes
            else:
                cur.execute(stmt)
                conn.commit()  # Save changes to the database
                results.append(("info", ["Message"], [(f"Executed ({cur.rowcount} rows affected)",)], stmt))
 
        except Error as e:
            # If something goes wrong, store it as an 'error' result so the UI can display it
            results.append(("error", ["Error"], [(str(e),)], stmt))
 
    # Return the list of results, which will be rendered in the UI
    return results
# =========================================
# 12. STREAMLIT UI CONFIGURATION
# =========================================
# This sets up how the page will look and what its title will be.
 
st.set_page_config(
    page_title="AI SQL Query Assistant",  # Title of the browser tab
    layout="wide"                         # 'wide' gives more horizontal space (good for tables)
)
 
# Add a title at the top of the Streamlit app
st.title("AI SQL Query Assistant")
 
 
# =========================================
# 13. TOP BAR SECTION
# =========================================
# This section contains:
#   - On the LEFT: a dropdown to select a database and a "Switch DB" button
#   - On the RIGHT: a display of the current DB and its tables list
 
# Create two columns — left is 1 part wide, right is 2 parts wide
col1, col2 = st.columns([1, 2])
 
# ---------- LEFT COLUMN: DATABASE SELECTOR ----------
with col1:
    db_list = []  # We'll populate this with all available databases
 
    try:
        # Use the MySQL cursor to list all databases
        cur = st.session_state.cursor
        cur.execute("SHOW DATABASES;")
        db_list = [r[0] for r in cur.fetchall()]  # Extract the DB names from the rows
 
    except Error as e:
        # If something goes wrong (e.g., connection lost), show the error
        st.error(f"DB list failed: {e}")
 
    # Create a dropdown (selectbox) to pick a database from the list
    selected_db = st.selectbox(
        "Select Database",
        db_list,
        # If current_db exists in the list, select it by default. Otherwise, default to index 0.
        index=db_list.index(st.session_state.current_db) if st.session_state.current_db in db_list else 0
    )
 
    # Create a button to switch database
    if st.button("Switch DB"):
        # When clicked, try to connect to the newly selected database
        if connect_to_db(selected_db):
            st.success(f"Switched to `{selected_db}`")
            # st.rerun() restarts the Streamlit script to refresh state after DB change
            st.rerun()
 
 
# ---------- RIGHT COLUMN: CURRENT DB + TABLES ----------
with col2:
    # Get the list of tables in the current database
    tables = get_existing_tables()
 
    # Show the name of the current DB in bold
    st.write(f"**Current DB:** `{st.session_state.current_db}`")
 
    # If there are tables, display them; otherwise, show a friendly message
    if tables:
        st.write(f"**Tables ({len(tables)}):** {', '.join(tables)}")
    else:
        st.info("No tables found in this DB")
 
 
# =========================================
# 14. TAB SECTION (Table Schemas | SQL Query | Query Explanation)
# =========================================
# Streamlit allows us to use "tabs" for different sections of the UI.
# We'll create three tabs:
#   1️Table Schemas → Show columns of each table
#   2️SQL Query → User enters natural language or SQL, runs it, sees results
#   3️Query Explanation → GPT explains the query in simple language
 
tab1, tab2, tab3 = st.tabs(["Table Schemas", "SQL Query", "Query Explanation"])
 
 
# ---------- TAB 1: TABLE SCHEMAS ----------
with tab1:
    # If there are tables, display their structure (columns, types, keys, etc.)
    if tables:
        st.subheader("Table Schemas")  # A sub-header inside the tab
 
        # Loop through each table in the current database
        for t in tables:
            st.markdown(f"### {t}")  # Display table name as a mini-title
 
            # Get the schema information (columns) for this table
            schema = get_table_schema(t)
 
            # Convert schema list into a Pandas DataFrame for nicer table formatting
            df = pd.DataFrame(
                schema,
                columns=["Field", "Type", "Null", "Key", "Default", "Extra"]
            )
 
            # Show the DataFrame inside Streamlit
            st.dataframe(df, use_container_width=True)  # use_container_width = make table full width
 
 
# ---------- TAB 2: SQL QUERY ----------
with tab2:
    st.subheader("Run SQL or Ask in Natural Language")
 
    # Create a large text area for the user to type their instruction or SQL query
    user_input = st.text_area(
        "Enter your instruction or SQL:",
        height=120,
        placeholder="e.g., Show all customers who made purchases in 2023",
        label_visibility="collapsed"  # Hide the label above the box (cleaner look)
    )
 
    # Create a "Run Query" button. 'type="primary"' gives it a blue color (important action)
    run_btn = st.button("Run Query", type="primary")
 
    # Only proceed if the user actually clicked the button and typed something
    if run_btn and user_input.strip():
        # Clear any previous explanation when a new query runs
        st.session_state.last_explanation = None
 
        # Show a loading spinner while we process the query
        with st.spinner("Running your SQL query..."):
            # Convert natural language → SQL using GPT
            sql = text_to_sql(user_input)
 
            # Show the generated SQL to the user for transparency
            st.subheader("Generated SQL")
            st.code(sql, language="sql")
 
            # Actually run the generated SQL against the database
            query_results = run_query(sql)
 
        # Store the results in session_state so that Streamlit reruns don't clear them
        st.session_state.last_results = query_results
 
        # Look through the results in reverse to find the LAST valid SELECT query
        # (This is the one we want GPT to explain)
        last_data_stmt = next(
            (stmt for rtype, _, _, stmt in reversed(query_results) if rtype == "data"),
            None
        )
 
        # If we found a SELECT statement, ask GPT to explain it
        if last_data_stmt:
            with st.spinner("Generating explanation..."):
                explain_prompt = f"""
You are a senior MySQL query analyst.
Explain in simple language why this query was used and what it does.
Then suggest if there's a more efficient or optimized way to write it.
 
Query:
{last_data_stmt}
                """
                st.session_state.last_explanation = client.responses.create(
                    model="gpt-4.1-mini",
                    input=explain_prompt
                ).output_text
 
 
# ---------- TAB 2: SHOW QUERY RESULTS (if any) ----------
# Even if the user doesn't click the button again, this block ensures results stay visible.
if "last_results" in st.session_state and st.session_state.last_results:
    for idx, (rtype, headers, rows, stmt) in enumerate(st.session_state.last_results, start=1):
        if rtype == "error":
            # Show error messages in red boxes
            st.error(rows[0][0])
        elif rtype == "info":
            # Show info messages in green boxes
            st.success(rows[0][0])
        elif rtype == "data":
            # ⚠️ This line below shows the SQL again (can be removed if duplicate)
            st.code(stmt, language="sql")
 
            # Convert the rows and headers into a Pandas DataFrame for display
            df = pd.DataFrame(rows, columns=headers)
 
            # Show the results in a scrollable table
            st.dataframe(df, use_container_width=True, height=400)
 
 
# ---------- TAB 3: QUERY EXPLANATION ----------
with tab3:
    st.subheader("Query Explanation & Optimization")
 
    # If we have a GPT-generated explanation stored, show it
    if st.session_state.last_explanation:
        # 'unsafe_allow_html=True' allows rich text formatting in the explanation
        st.markdown(st.session_state.last_explanation, unsafe_allow_html=True)
    else:
        # If no query was run yet, show a warning
        st.warning("Run a query first to enable this tab.")
# =========================================
# 15. GLOBAL STYLING (CUSTOM CSS)
# =========================================
# Streamlit doesn't allow full CSS customization by default,
# but we can inject custom CSS styles using st.markdown() with HTML and <style> tags.
# This is useful to tweak UI behavior in ways Streamlit doesn't natively support.
 
st.markdown(
    """
    <style>
    /* ===============================
       DISABLE THE "Query Explanation" TAB
       WHEN NO EXPLANATION EXISTS
       =============================== */
 
    /* Target the 3rd tab button (Query Explanation tab) specifically */
    div[data-testid="stTabs"] button:nth-child(3) {
        position: relative;  /* allows us to position tooltips relative to the tab */
    }
 
    /* If the tab has no content (no div, em, or code elements inside), disable it */
    div[data-testid="stTabs"] button:nth-child(3):not(:has(div)):not(:has(em)):not(:has(code)) {
        pointer-events: none;   /* disables clicks on the tab */
        opacity: 0.5;           /* makes the tab look faded (disabled) */
        cursor: not-allowed;    /* changes cursor to a "🚫" symbol */
    }
 
    /* Tooltip shown on hover when the tab is disabled */
    div[data-testid="stTabs"] button:nth-child(3):not(:has(div)):hover::after {
        content: "Run a query first to view explanation.";  /* Tooltip message */
        position: absolute;
        top: 100%;             /* place it just below the tab */
        left: 50%;             /* center horizontally */
        transform: translateX(-50%);
        background: #333;      /* dark tooltip background */
        color: #fff;           /* white text */
        padding: 6px 10px;     /* padding around the tooltip */
        border-radius: 5px;    /* rounded corners */
        font-size: 0.85rem;    /* slightly smaller text */
        white-space: nowrap;   /* prevent text wrapping */
        z-index: 9999;         /* bring it to the front */
    }
    </style>
    """,
    unsafe_allow_html=True  # Allow raw HTML and CSS to be injected
)